## 计网
* 常见的HTTP状态码有哪些，分别代表什么意思

## JS
* 如何判断this指向

## css
```html
<div class="app">
    <div>
        <h1>标题</h1>
        <p class="color-blue color-red color-yellow">什么颜色</p>
    </div>
</div>
```
```css
.app p{
    color: black;
}
.app .color-yellow{
    color: yellow;
}

.app .color-red{
    color: red;
}

p.color-color-blue{
    color: blue;
}
```

1. 运行后上面的p标签什么颜色
2. css样式权重如何计算的？
3. 存在冲突时，层叠值（一个元素有多个样式规则）计算规则是怎样的？

**tl**
```
常见的HTTP状态码有哪些，分别代表什么意思：
200~299：请求成功响应，比如200表示请求成功
300~399：请求跳转，比如304表示请求重定向
400~499：页面错误，比如404表示页面找不到
500~599：服务器错误

如何判断this指向：
函数直接执行this指向window
函数通过对象调用this指向直接调用的对象
通过bind，call，apply调用的函数this指向传入的第一个参数
箭头函数内部的this指向外部第一个普通函数的this
通过new调用的函数内部this指向新分配的对象

运行后上面的p标签什么颜色：
红色

css样式权重如何计算的？：
内嵌样式权重1000
id选择器权重0100
类选择器权重0010
标签选择器权重0001
通配符选择器权重0000
按选择器包含的种类相加，每位独立不发生进位。结果越大的权重越高

存在冲突时，层叠值（一个元素有多个样式规则）计算规则是怎样的？
内嵌样式＞外部样式=内部样式
后出现的样式＞先出现的样式
！important修饰样式的优先级最高
程序员给的样式＞继承的样式＞浏览器的默认样式
```

**tdk**
```
1.http常见状态码
200 客户端发送给服务器的请求被正常处理并返回
202 接受请求，但是没有处理资源返回
204 处理了请求但是没有返回资源
301 永久性重定向
302 临时性重定向
400 表示请求报文中存在语法错误
401 未经许可，需要通过HTTP认证
403 服务器拒绝该次访问
404 表示服务器上无法找到请求的资源
405 服务器不允许该类请求
500 表示服务器在执行请求时发生了错误
502 错误的网关
503 服务器不可用
504 网关超时

2.this指向
1.如果是一般函数,this指向全局对象window;
2.在严格模式下"use strict",为undefined.
3.对象的方法里调用,this指向调用该方法的对象.
4.构造函数里的this,指向创建出来的实例
5.箭头函数的this指向指向箭头函数定义时所处的对像

3
3.1
red（我猜的）
3.2
样式权重
非组合选择器
 ！important > 行间样式 > id选择器 > 类，伪类和属性选择器 > 类型（标签）选择器和伪元素选择器 > 通配符、子选择器、相邻选择器等的。如*、>、+  > 继承的样式 
权重从高到底为 无限大 1000 0100 0010 0001 0000 无 无法进位不行就是不行
10个div也比不上一个.class

组合选择器
把各种选择器的权重相比，来计算权重大小
对于同一权重 讲究先来后到

3.3
权重高的覆盖权重低的，对于同一权重 讲究先来后到
```

**lj**
```
状态码：
200:一切正常。
400：客户端问题
500:   服务端问题 
404：资源不存在
判断this指向：
下面这个题是上次有写过的
let obj2 = {
    name: 'obj2'
}
const obj = {
    name: 'obj',
    say1() {
        console.log(this.name)//obj.say1()中的this指向obj;
    },
    obj1: {
        name: 'obj1',
        say2() {
            console.log(this.name);//obj.obj1.say2()中的this指向obj1;
        }
    },
    say3() {
        const fn = () => {
            console.log(this.name);//obj  箭头函数this无效，单独执行fn，this为fn的上一级包裹（obj）
        }
        fn()
    },
    say4() {
        const fn = function () {
            console.log(this.name);//预计是全局  单独执行fn,this为全局
        }
        fn()
    },
    say5() {
        const fn = () => {
            console.log(this.name);
        }
        fn.call(obj2)//预计是obj
    },
    say6() {
        const fn = function () {
            console.log(this.name);
        }
        fn.call(obj2)//预计是obj2
    }
}
let a = obj.say1
let b = obj.obj1.say2
a()  //全局对象  ---------------------------- 答案：undefined
b() //全局对象  ---------------------------------- undefined
obj.say1() //obj;--------------------------------obj
obj.obj1.say2() //obj1;---------------------------obj1
obj.say3() //全局对象------------------------------obj
obj.say4() //预计是obj-----------------------------undefined
obj.say5() // 预计是obj2---------------------------obj
obj.say6() //预计是obj2----------------------------obj2

运行之后颜色是红色

权重计算：
内联第一重1000
id第二重100
类第三重10
元素第四重1
然后按照这个顺序计算权重值
值一样的看代码先后
还有一个!important
```
